## 启动阶段

### 1. 程序入口
```java
public static void main(String[] args) throws Exception {
    String base = (args.length > 0) ? args[0] : "http://localhost:8080";
    String startPath = (args.length > 1) ? args[1] : "/";
    
    AsyncSpider spider = new AsyncSpider();
    List<String> result = spider.crawl(URI.create(base), startPath, Duration.ofSeconds(180));
    
    result.forEach(System.out::println);
}
```
**执行流程：**
1. 检查命令行参数，设置默认值
2. 创建 `AsyncSpider` 实例
3. 调用 `crawl` 方法开始爬取
4. 输出最终结果

## 核心爬取过程

### 2. crawl 方法执行流程

```java
public List<String> crawl(URI base, String startPath, Duration globalTimeout)
```

#### 步骤1：初始化阶段
```java
try (ExecutorService vexec = Executors.newVirtualThreadPerTaskExecutor()) {
    AtomicInteger inFlight = new AtomicInteger(0);  // 初始值：0
    CountDownLatch done = new CountDownLatch(1);    // 初始值：1
    
    long deadlineNanos = System.nanoTime() + globalTimeout.toNanos();
```

**此时状态：**
- `inFlight = 0`：还没有任务在运行
- `done = 1`：门闩处于"未完成"状态
- 创建了虚拟线程池

#### 步骤2：创建任务提交器
```java
Runnable submit = new Runnable() {
    void fork(String path) {
        if (!visited.add(path)) return;  // 检查是否已访问
        inFlight.incrementAndGet();      // 增加任务计数
        
        vexec.submit(() -> {
            try {
                // 实际处理逻辑
            } finally {
                if (inFlight.decrementAndGet() == 0)
                    done.countDown();  // 所有任务完成
            }
        });
    }
    
    public void run() {
        fork(startPath);  // 从这里开始
    }
};
```

#### 步骤3：启动爬取
```java
submit.run();
```

**第一次调用 `fork("/")` 的过程：**
1. `visited.add("/")` → 成功，继续执行
2. `inFlight.incrementAndGet()` → `inFlight = 1`
3. 提交任务到虚拟线程池执行

### 4. 虚拟线程中的任务执行

```java
vesec.submit(() -> {
    try {
        Node node = fetchNode(base.resolve(path));  // 1. 获取数据
        if (node != null) {
            if (node.message() != null && !node.message().isBlank())
                allMessages.add(node.message());    // 2. 收集消息
            
            for (String next : node.successors()) {
                fork(next);  // 3. 递归处理链接
            }
        }
    } finally {
        if (inFlight.decrementAndGet() == 0)
            done.countDown();
    }
});
```

#### 具体示例执行流程

假设服务器返回的数据结构如下：

**起始页面 (`/`):**
```json
{
    "message": "首页欢迎信息",
    "successors": ["/about", "/products"]
}
```

**执行步骤：**

1. **处理 `/`**：
    - `fetchNode("http://localhost:8080/")` 获取数据
    - 将 "首页欢迎信息" 添加到 `allMessages`
    - 发现两个链接：`/about` 和 `/products`
    - 调用 `fork("/about")` 和 `fork("/products")`

2. **处理 `/about`**：
   ```json
   {
       "message": "关于我们",
       "successors": ["/contact"]
   }
   ```
    - 添加 "关于我们" 到消息列表
    - 发现新链接 `/contact`，调用 `fork("/contact")`

3. **处理 `/products`**：
   ```json
   {
       "message": "产品列表",
       "successors": ["/product/1", "/product/2"]
   }
   ```
    - 添加 "产品列表" 到消息列表
    - 发现两个产品链接

4. **处理 `/contact`**：
   ```json
   {
       "message": "联系方式",
       "successors": []
   }
   ```
    - 添加 "联系方式" 到消息列表
    - 没有更多链接，任务完成

5. **处理产品页面**...（继续递归）

### 5. 并发执行的可视化

```
时间轴：
t0: 开始处理 "/"          [inFlight: 1]
     ↓
t1: 发现 "/about", "/products"
    提交两个新任务         [inFlight: 1 + 2 = 3]
    完成 "/" 处理         [inFlight: 3 - 1 = 2]
    
t2: 同时处理 "/about" 和 "/products"
    "/about": 发现 "/contact" → 提交新任务 [inFlight: 2 + 1 = 3]
    "/products": 发现两个产品链接 → 提交两个任务 [inFlight: 3 + 2 = 5]
    分别完成处理           [inFlight: 5 - 2 = 3]
    
t3: 处理 "/contact" 和两个产品页面
    "/contact": 无新链接 → 完成 [inFlight: 3 - 1 = 2]
    产品页面：可能发现更多链接...
    
t4: 所有任务逐渐完成
    [inFlight: 2 → 1 → 0]
    
t5: inFlight = 0 → done.countDown() → 主线程继续执行
```

### 6. 主线程的等待逻辑

```java
long remaining;
while ((remaining = deadlineNanos - System.nanoTime()) > 0) {
    if (done.await(Math.min(TimeUnit.NANOSECONDS.toMillis(remaining), 250), TimeUnit.MILLISECONDS))
        break;
}
```

**等待过程：**
1. 计算剩余时间
2. 最多等待250毫秒或剩余时间（取较小值）
3. 如果 `done` 门闩被触发（所有任务完成），跳出循环
4. 否则继续等待，直到超时

### 7. HTTP请求的详细流程

当执行 `fetchNode(uri)` 时：

```java
private Node fetchNode(URI uri) {
    for (int attempt = 0; attempt <= MAX_RETRIES; attempt++) {
        try {
            // 构建请求
            HttpRequest req = HttpRequest.newBuilder(uri)
                    .timeout(REQ_TIMEOUT)
                    .GET()
                    .build();
            
            // 发送请求（这里会"阻塞"虚拟线程，但不会阻塞平台线程）
            HttpResponse<String> resp = client.send(req, HttpResponse.BodyHandlers.ofString());
            
            if (resp.statusCode() == 200) {
                return parseNode(resp.body());  // 解析JSON
            }
        } catch (IOException e) {
            // 网络错误，重试
            if (attempt == MAX_RETRIES) return null;
        }
    }
    return null;
}
```

**关键点：** 虚拟线程在 `client.send()` 处被挂起，但平台线程可以继续执行其他虚拟线程。

### 8. 数据解析过程

```java
private static Node parseNode(String json) {
    // 1. 提取 message
    Matcher m = MESSAGE_P.matcher(json);
    if (m.find())
        message = unescape(m.group(1));  // 处理转义字符

    // 2. 提取 successors 数组
    List<String> successors = new ArrayList<>();
    Matcher s = SUCCESSORS_P.matcher(json);
    if (s.find()) {
        String arr = s.group(1);
        Matcher each = STRING_IN_ARRAY_P.matcher(arr);
        while (each.find())
            successors.add(unescape(each.group(1)));
    }

    return new Node(message, successors);
}
```

### 9. 完成阶段

当所有任务都完成时：

1. 最后一个任务的 `finally` 块执行：
   ```java
   if (inFlight.decrementAndGet() == 0)  // inFlight 从 1 变为 0
       done.countDown();                 // 触发门闩
   ```

2. 主线程从等待中恢复
3. 收集并排序消息：
   ```java
   var list = new ArrayList<>(allMessages);
   list.sort(Comparator.naturalOrder());
   return list;
   ```

4. 在 `main` 方法中输出结果

## 关键特性总结

1. **深度优先的并发遍历**：虽然代码看起来像深度优先，但由于并发执行，实际是混合顺序
2. **自动避免循环**：通过 `visited` 集合防止重复访问
3. **弹性重试**：网络失败时自动重试
4. **超时控制**：防止程序无限运行
5. **高效并发**：使用虚拟线程，可以同时处理数千个请求

这个流程展示了程序如何从一个起点开始，像水波一样扩散开来，并发地探索整个网站结构，最终收集所有信息。